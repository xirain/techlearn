---
title: 算法题型汇总学习教程（C++）—— 必会与进阶路线 + 示例题
description: 按考察频率整理算法题型（必会/进阶），给出学习顺序、刷题方法与 C++ 示例，包含动态规划专项实战
date: 2026-02-28
categories: [数据结构]
tags: [c++, 算法, 刷题, 动态规划, 图论, 树, BFS, DFS, 前缀和, 并查集]
---

很多同学刷题时最大的问题不是“不会写代码”，而是**不知道先学什么、先刷什么**。

这篇文章按你给出的题型清单，结合面试频率，整理成一份可执行的学习路线：

- 先打牢 **必会题型（高频）**
- 再突破 **进阶题型（拉开差距）**
- 每个题型给出学习重点 + 典型示例题方向
- 对动态规划单独给出由浅入深的 C++ 实战模板

---

## 题型汇总（按难度与频率）

按照算法的难度和频率大致分为「必会」和「进阶」两种类型；每个子项的序号越小，通常考察频率越高。实际刷题建议结合题库的**热度、题解数、通过率**进行筛选。

### 必会

1. 数组  
2. 字符串  
3. 排序  
4. 贪心  
5. 递归  
6. 循环  
7. 滑窗  
8. 栈  
9. 进制转换  
10. 位运算  
11. 队列  
12. 哈希表  
13. 链表  
14. 线性表  
15. 二分查找  

### 进阶

1. 图  
2. 树  
3. DFS 搜索  
4. BFS 搜索  
5. 动态规划  
6. 前缀和  
7. 排列组合  
8. 矩阵  
9. 双指针  
10. 回溯  
11. 状态机  
12. 并查集  
13. 正则表达式  
14. 分治  
15. 枚举  
16. 统计  

---

## 学习教程：四阶段刷题法

## 阶段 1：必会基础（1~3 周）

目标：把数组、字符串、哈希、双指针/滑窗、栈队列、二分练成“条件反射”。

- 每天 3 题：2 道新题 + 1 道复盘题
- 每道题输出固定模板：
  1) 数据结构选择  
  2) 时间/空间复杂度  
  3) 边界样例

## 阶段 2：进阶入口（2~3 周）

目标：树、图、搜索建立统一模型。

- 图：邻接表 + BFS/DFS + 最短路入门
- 树：递归模板 + 层序模板 + 路径类题

## 阶段 3：动态规划专项（2 周）

目标：建立 DP 的“状态定义能力”。

- 线性 DP → 背包 DP → 序列 DP → 区间 DP → 状压 DP
- 强制写出：状态、转移、初始化、遍历顺序

## 阶段 4：综合冲刺（持续）

目标：面试表达 + 复杂场景迁移。

- 混合题（图 + DP、前缀和 + 二分、树 + 回溯）
- 限时训练：25 分钟思路 + 编码 + 样例验证

---

## 必会题型学习要点 + 示例

| 题型 | 先学什么 | 典型示例方向 |
|---|---|---|
| 数组 | 遍历、前后缀、原地操作 | 两数之和、合并区间 |
| 字符串 | 子串、匹配、计数 | 最长无重复子串、字符串压缩 |
| 排序 | 快排/归并思想、稳定性 | 数组第 K 大、区间排序 |
| 贪心 | 局部最优到全局最优 | 跳跃游戏、区间调度 |
| 递归 | 终止条件、子问题分解 | 汉诺塔、二叉树遍历 |
| 循环 | 多层循环优化 | 螺旋矩阵、模拟题 |
| 滑窗 | 双指针移动规则 | 最小覆盖子串、定长窗口最大值 |
| 栈 | 单调栈、括号匹配 | 每日温度、有效括号 |
| 进制转换 | 进制映射与取模 | 十进制转二进制、进制加法 |
| 位运算 | 与或异或、位掩码 | 只出现一次的数字、子集枚举 |
| 队列 | 普通队列、双端队列 | 滑动窗口最大值 |
| 哈希表 | 频次统计、映射查找 | 字母异位词分组 |
| 链表 | 指针操作、快慢指针 | 反转链表、环形链表 |
| 线性表 | 顺序/链式存储思想 | 删除重复元素 |
| 二分查找 | 边界收敛模板 | 搜索旋转数组、答案二分 |

---

## 进阶题型学习要点 + 示例

| 题型 | 学习重点 | 典型示例方向 |
|---|---|---|
| 图 | 建图、遍历、最短路 | 课程表、Dijkstra |
| 树 | 前中后序、路径问题 | 最近公共祖先、路径和 |
| DFS 搜索 | 深度遍历 + 回溯 | 岛屿数量、组合求和 |
| BFS 搜索 | 层序最短步数 | 最短路径、腐烂橘子 |
| 动态规划 | 状态与转移建模 | 打家劫舍、LCS、背包 |
| 前缀和 | 区间和 O(1) 查询 | 子数组和等于 K |
| 排列组合 | 排列/组合生成 | 全排列、组合总和 |
| 矩阵 | 坐标移动、边界控制 | 旋转图像、矩阵置零 |
| 双指针 | 同向/相向夹逼 | 三数之和、盛最多水容器 |
| 回溯 | 选择-递归-撤销 | N 皇后、子集问题 |
| 状态机 | 状态转移设计 | 股票买卖系列 |
| 并查集 | 合并、路径压缩 | 省份数量、冗余连接 |
| 正则表达式 | 模式匹配建模 | 通配符匹配、正则匹配 |
| 分治 | 分解与合并 | 归并排序、快速幂 |
| 枚举 | 有界搜索与剪枝 | 回文枚举、子集枚举 |
| 统计 | 频次、计数优化 | Top K 高频元素 |

---

## 动态规划专项：由浅入深 C++ 实战

动态规划在进阶中排第 5，但在面试中常是区分度最高的模块，建议专项突破。

### 统一 DP 模板（先背这个）

1. 定义状态：`dp[i]` / `dp[i][j]` 表示什么
2. 写转移：从哪些更小状态来
3. 设初始化：最小规模如何成立
4. 定遍历：为什么这个顺序正确
5. 取答案：`dp[n]` 或全局最值

### 示例 1：爬楼梯（线性 DP 入门）

```cpp
#include <bits/stdc++.h>
using namespace std;

int climbStairs(int n) {
    if (n <= 1) return 1;
    vector<int> dp(n + 1, 0);
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

- 状态：`dp[i]` 到第 i 阶的方法数
- 转移：来自 `i-1` 和 `i-2`
- 复杂度：`O(n)`

### 示例 2：01 背包（经典 DP）

```cpp
#include <bits/stdc++.h>
using namespace std;

int knapsack01(const vector<int>& w, const vector<int>& v, int W) {
    vector<int> dp(W + 1, 0);
    for (int i = 0; i < (int)w.size(); ++i) {
        for (int j = W; j >= w[i]; --j) { // 01背包倒序
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
        }
    }
    return dp[W];
}
```

- 高频考点：01 背包必须容量倒序
- 易错点：顺序写错会变成“完全背包”

### 示例 3：最长公共子序列 LCS（序列 DP）

```cpp
#include <bits/stdc++.h>
using namespace std;

int lcs(const string& a, const string& b) {
    int n = (int)a.size(), m = (int)b.size();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (a[i - 1] == b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
    return dp[n][m];
}
```

- 关键：先说清 `dp[i][j]` 的含义，再写代码

### 示例 4：状态压缩 DP（TSP 入门）

```cpp
#include <bits/stdc++.h>
using namespace std;

int tsp(const vector<vector<int>>& dist) {
    const int INF = 1e9;
    int n = (int)dist.size();
    int S = 1 << n;
    vector<vector<int>> dp(S, vector<int>(n, INF));
    dp[1][0] = 0;

    for (int mask = 1; mask < S; ++mask) {
        for (int u = 0; u < n; ++u) {
            if (!(mask & (1 << u)) || dp[mask][u] == INF) continue;
            for (int v = 0; v < n; ++v) {
                if (mask & (1 << v)) continue;
                int nxt = mask | (1 << v);
                dp[nxt][v] = min(dp[nxt][v], dp[mask][u] + dist[u][v]);
            }
        }
    }

    int full = S - 1, ans = INF;
    for (int u = 0; u < n; ++u) ans = min(ans, dp[full][u] + dist[u][0]);
    return ans;
}
```

- 复杂度：`O(n^2 * 2^n)`
- 适用：城市数较小但要求精确最优解

---

## 刷题建议：频率优先 + 结构化复盘

1. **先高频后低频**：先把必会题型刷透，再啃进阶。
2. **每题写 3 行复盘**：
   - 本题核心模式是什么？
   - 下次怎么 30 秒识别？
   - 哪个边界最容易错？
3. **每周做一次专题复训**：例如“本周只做滑窗 + 哈希”。
4. **动态规划要手推表格**：不手推，转移很难真正吃透。

---

## 结语

算法学习不是“题海战术”，而是“题型识别 + 模板迁移 + 复盘迭代”。

你可以把本文当成路线图：先必会、再进阶、最后做融合题。尤其是动态规划，只要把状态定义训练到位，难题也会逐步模板化。

如果你愿意，我下一篇可以给你整理：

> 《按面试频率排序的 100 题 C++ 刷题清单（含每题所属题型与推荐顺序）》
